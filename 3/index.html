<!DOCTYPE html>
<html>
<head>
    <title>Project 3: Face Morphing and Mosaicing</title>
    <style>
        body {
            font-family: Times, sans-serif;
            margin: 20px;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }
        .image-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .image-container {
            text-align: center;
            flex: 1;
            min-width: 300px;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .full-width-image {
            text-align: center;
            margin: 20px 0;
        }
        .full-width-image img {
            max-width: 90%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .equation {
            background-color: #f9f9f9;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4CAF50;
            font-family: 'Courier New', monospace;
        }
    </style>
    <!-- Prism.js CSS -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
    <!-- MathJax for LaTeX equations -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
</head>
<body>
    <h1>Project 3: Face Morphing and Mosaicing</h1>
    <p><strong>Daniel Bronfman</strong></p>

    <h2>Overview</h2>
    <p>In this project, I implemented image mosaicing by computing homographies, warping images using different interpolation methods, and blending them together. The project demonstrates homography recovery, image rectification, and panorama creation through projective transformations.</p>

    <!-- ============= PART A.1 ============= -->
    <h2>Part A.1: Shoot and Digitize Pictures</h2>
    <p>I captured multiple sets of photographs with projective transformations between them. The key technique was to fix the center of projection (camera position) and rotate the camera to capture overlapping views. This ensures the transformation between images is a pure homography (projective transformation).</p>

    <h3>Image Set 1: Robotics Lab (ur1 & ur2)</h3>
    <p>This set captures the robotics lab with detailed features for correspondence matching. Shot by rotating the camera while keeping the center of projection fixed.</p>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/ur1.jpg" alt="Robotics lab 1">
            <p><strong>Robotics Lab 1 (Left view)</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/ur2.jpg" alt="Robotics lab 2">
            <p><strong>Robotics Lab 2 (Right view)</strong></p>
        </div>
    </div>

    <h3>Image Set 2: Outdoor Scene (p3 & p4)</h3>
    <p>Another set showing an outdoor scene with good feature overlap for correspondence matching.</p>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/p3.jpg" alt="Outdoor scene 1">
            <p><strong>Image 1 (Left view)</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/p4.jpg" alt="Outdoor scene 2">
            <p><strong>Image 2 (Right view)</strong></p>
        </div>
    </div>

    <!-- ============= PART A.2 ============= -->
    <h2>Part A.2: Recover Homographies</h2>
    <p>To align images, I implemented homography recovery from point correspondences. A homography is a 3x3 matrix \(H\) that maps points from one image to another: \(\mathbf{p'} = H\mathbf{p}\).</p>

    <h3>Mathematical Formulation</h3>
    <p>Given \(n\) point correspondences \((\mathbf{p}_i, \mathbf{p'}_i)\), where \(\mathbf{p}_i = (x_i, y_i)\) and \(\mathbf{p'}_i = (u_i, v_i)\), we can set up a system of equations. For each correspondence, the homography gives us:</p>

    <p style="text-align: center;">
        $$\begin{bmatrix} u_i \\ v_i \\ 1 \end{bmatrix} = \begin{bmatrix} h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & 1 \end{bmatrix} \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}$$
    </p>

    <p>Expanding and rearranging (setting \(h_{33} = 1\) for the 8 degrees of freedom), each point gives us two equations:</p>

    <p style="text-align: center;">
        $$h_{11}x + h_{12}y + h_{13} - uh_{31}x - uh_{32}y = u$$
        $$h_{21}x + h_{22}y + h_{23} - vh_{31}x - vh_{32}y = v$$
    </p>

    <p>With \(n\) correspondences, we get \(2n\) equations. This forms a linear system \(\mathbf{Ah} = \mathbf{b}\), where:</p>

    <p style="text-align: center;">
        $$A = \begin{bmatrix}
        x_1 & y_1 & 1 & 0 & 0 & 0 & -u_1x_1 & -u_1y_1 \\
        0 & 0 & 0 & x_1 & y_1 & 1 & -v_1x_1 & -v_1y_1 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        x_n & y_n & 1 & 0 & 0 & 0 & -u_nx_n & -u_ny_n \\
        0 & 0 & 0 & x_n & y_n & 1 & -v_nx_n & -v_ny_n
        \end{bmatrix}, \quad
        \mathbf{h} = \begin{bmatrix} h_{11} \\ h_{12} \\ h_{13} \\ h_{21} \\ h_{22} \\ h_{23} \\ h_{31} \\ h_{32} \end{bmatrix}, \quad
        \mathbf{b} = \begin{bmatrix} u_1 \\ v_1 \\ \vdots \\ u_n \\ v_n \end{bmatrix}$$
    </p>

    <p>For \(n = 4\), this system is exactly determined. For \(n > 4\), we have an overdetermined system and solve using least-squares: \(\mathbf{h} = (A^TA)^{-1}A^T\mathbf{b}\), which in practice is computed using <code>np.linalg.lstsq()</code>.</p>

    <h3>Implementation</h3>
    <p>Here's my implementation of <code>computeH(im1_pts, im2_pts)</code>:</p>

    <pre><code class="language-python">def computeH(im1_pts, im2_pts):
    n = im1_pts.shape[0]
    A = []
    b = []

    for i in range(n):
        x, y = im1_pts[i]
        u, v = im2_pts[i]

        A.append([x, y, 1, 0, 0, 0, -u*x, -u*y])
        b.append(u)

        A.append([0, 0, 0, x, y, 1, -v*x, -v*y])
        b.append(v)

    A = np.array(A)
    b = np.array(b)

    h, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)

    H = np.array([
        [h[0], h[1], h[2]],
        [h[3], h[4], h[5]],
        [h[6], h[7], 1.0]
    ])

    return H</code></pre>

    <h3>Point Correspondences</h3>
    <p>I used matplotlib's <code>ginput()</code> function to manually select corresponding points between image pairs. The tool displays both images side-by-side and allows clicking matching features in order. Typically, I selected 8-12 correspondences for robust homography estimation.</p>

    <h3>Example: Whiteboard Correspondence</h3>
    <p>Here's an example using the whiteboard images with 4 correspondence points:</p>

    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/whiteboard1.jpg" alt="Whiteboard 1">
            <p><strong>Whiteboard Image 1</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/whiteboard2.jpg" alt="Whiteboard 2">
            <p><strong>Whiteboard Image 2</strong></p>
        </div>
    </div>

    <p>The computed homography matrix mapping whiteboard1 to whiteboard2:</p>
    <p style="text-align: center;">
        $$H = \begin{bmatrix}
        1.4448 & -0.0323 & -2258.5 \\
        0.3376 & 1.2734 & -1026.3 \\
        0.0001086 & -0.000005349 & 1.0000
        \end{bmatrix}$$
    </p>

    <!-- ============= PART A.3 ============= -->
    <h2>Part A.3: Warp the Images</h2>
    <p>With the homography computed, I implemented image warping using inverse warping to avoid holes in the output. I implemented two interpolation methods and compared their quality and performance.</p>

    <h3>Inverse Warping Approach</h3>
    <p>Instead of mapping source pixels to destination (forward warping, which creates holes), I use inverse warping:
    <ol>
        <li>For each pixel \((x', y')\) in the output image</li>
        <li>Apply \(H^{-1}\) to find where it maps in the source: \((x, y) = H^{-1}(x', y')\)</li>
        <li>Interpolate the color from the source image at location \((x, y)\)</li>
        <li>Assign that color to the output pixel \((x', y')\)</li>
    </ol>
    </p>

    <h3>Interpolation Methods</h3>

    <h4>1. Nearest Neighbor Interpolation</h4>
    <p>Round the source coordinates \((x, y)\) to the nearest integer pixel. Fast but produces blocky artifacts.</p>
    <pre><code class="language-python">def warpImageNearestNeighbor(im, H, output_width=None, output_height=None):
    h, w, c = im.shape

    if output_width and output_height:
        out_h, out_w = output_height, output_width
    else:
        out_h, out_w = get_output_dimensions(im, H)

    new_image = np.zeros((out_h, out_w, c + 1))
    H_inv = np.linalg.inv(H)

    for i in range(out_h):
        for j in range(out_w):
            dst_coord = np.array([j, i, 1])
            src_coord = H_inv @ dst_coord
            src_coord = src_coord / src_coord[2]
            src_x, src_y = src_coord[:2]

            src_x_nn = int(round(src_x))
            src_y_nn = int(round(src_y))

            if 0 <= src_x_nn < w and 0 <= src_y_nn < h:
                new_image[i, j, :-1] = im[src_y_nn, src_x_nn]
                new_image[i, j, -1] = 1

    return new_image</code></pre>

    <h4>2. Bilinear Interpolation</h4>
    <p>Use weighted average of the four neighboring pixels based on fractional coordinates. Slower but produces much smoother results.</p>
    <pre><code class="language-python">def warpImageBilinear(im, H, output_width=None, output_height=None):
    h, w, c = im.shape

    if output_width and output_height:
        out_h, out_w = output_height, output_width
    else:
        out_h, out_w = get_output_dimensions(im, H)

    new_image = np.zeros((out_h, out_w, c))
    H_inv = np.linalg.inv(H)

    for i in range(out_h):
        for j in range(out_w):
            dst_coord = np.array([j, i, 1])
            src_coord = H_inv @ dst_coord
            src_coord = src_coord / src_coord[2]
            src_x, src_y = src_coord[:2]

            x0, x1 = int(np.floor(src_x)), int(np.floor(src_x)) + 1
            y0, y1 = int(np.floor(src_y)), int(np.floor(src_y)) + 1

            fx = src_x - x0
            fy = src_y - y0

            if 0 <= x0 < w and 0 <= x1 < w and 0 <= y0 < h and 0 <= y1 < h:
                new_image[i, j] = (1-fx)*(1-fy)*im[y0, x0] + \
                                  fx*(1-fy)*im[y0, x1] + \
                                  (1-fx)*fy*im[y1, x0] + \
                                  fx*fy*im[y1, x1]

    return new_image</code></pre>

    <h3>Rectification Examples</h3>
    <p>To test the warping implementation, I performed "rectification" - making distorted rectangles appear frontal and rectangular. I selected 4 corners of a known rectangular object (poster, book cover) and mapped them to a perfect rectangle.</p>

    <h4>Example 1: Poster Rectification</h4>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/poster.jpg" alt="Original poster">
            <p><strong>Original (perspective distorted)</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/poster.png" alt="Rectified poster">
            <p><strong>Rectified (frontal view)</strong></p>
        </div>
    </div>

    <h4>Example 2: Book Cover Rectification</h4>
    <div class="full-width-image">
        <img src="images/part3/Rectification_1.png" alt="Book rectification comparison">
        <p><strong>Rectification comparison showing original and warped result</strong></p>
    </div>

    <h3>Speed vs Quality Comparison</h3>
    <p>I compared the two interpolation methods:</p>
    <ul>
        <li><strong>Nearest Neighbor:</strong> ~0.5-2 seconds for typical images. Produces blocky/pixelated edges but is simple and fast.</li>
        <li><strong>Bilinear:</strong> ~2-8 seconds (approximately 3-4x slower). Produces smooth, high-quality results with anti-aliased edges.</li>
    </ul>
    <p><strong>Trade-off:</strong> For final results, bilinear interpolation is preferred due to significantly better visual quality. Nearest neighbor is useful for quick testing and debugging. The computational overhead of bilinear is acceptable for most applications since warping is typically a one-time operation.</p>

    <!-- ============= PART A.4 ============= -->
    <h2>Part A.4: Blend Images into a Mosaic</h2>
    <p>The final step is combining multiple warped images into a seamless mosaic. I implemented weighted blending to avoid harsh edges in overlap regions.</p>

    <h3>Mosaicing Procedure</h3>
    <ol>
        <li><strong>Choose reference image:</strong> One image stays in its original coordinate system</li>
        <li><strong>Warp other images:</strong> Use \(H^{-1}\) to transform other images into the reference frame</li>
        <li><strong>Compute canvas size:</strong> Find bounding box that contains all images by transforming corners</li>
        <li><strong>Composite with blending:</strong> In overlap regions, use weighted averaging to smoothly blend</li>
    </ol>

    <h3>Blending Strategy</h3>
    <p>For pixels where both images have content (overlap region), I use weighted averaging:</p>
    <p style="text-align: center;">
        $$\text{output\_pixel} = \alpha \times \text{image1\_pixel} + (1 - \alpha) \times \text{image2\_pixel}$$
    </p>
    <p>I typically use \(\alpha = 0.6\) to give slight preference to the reference image, though \(\alpha = 0.5\) produces symmetric blending.</p>

    <h3>Mosaic Results</h3>

    <p><strong>Note:</strong> Some of the following mosaics exhibit distortion and alignment issues due to inaccurate homography matrices. These H matrices were computed using too few correspondence points (4-8 points). Better results would be achieved with 12-20 correspondence points for more robust homography estimation.</p>

    <h4>Mosaic 1: Robotics Lab (ur1 & ur2)</h4>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/ur1.jpg" alt="Robotics lab source 1">
            <p><strong>Robotics Lab Source 1</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/ur2.jpg" alt="Robotics lab source 2">
            <p><strong>Robotics Lab Source 2</strong></p>
        </div>
    </div>
    <div class="full-width-image">
        <img src="images/part3/ur7e_mosaic.png" alt="Robotics lab mosaic">
        <p><strong>Merged Mosaic - Robotics Lab</strong></p>
    </div>
    <p>This robotics lab mosaic shows some distortion artifacts. The quality could be significantly improved by using more correspondence points (e.g., 12-20 instead of 4-8) to compute a more accurate homography matrix H.</p>

    <h4>Mosaic 2: Outdoor Scene (p3 & p4)</h4>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/p3.jpg" alt="Outdoor source 1">
            <p><strong>Outdoor Source 1</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/p4.jpg" alt="Outdoor source 2">
            <p><strong>Outdoor Source 2</strong></p>
        </div>
    </div>
    <div class="full-width-image">
        <img src="images/part3/shitty_mosaic_1.png" alt="Outdoor mosaic">
        <p><strong>Merged Mosaic - Outdoor Scene</strong></p>
    </div>
    <p>This outdoor scene mosaic demonstrates blending across natural lighting variations with smooth transitions in the overlap region.</p>

    <h4>Mosaic 3: Whiteboard Panorama (whiteboard1 & whiteboard2)</h4>
    <div class="image-row">
        <div class="image-container">
            <img src="images/part3/whiteboard1.jpg" alt="Whiteboard source 1">
            <p><strong>Whiteboard Source 1</strong></p>
        </div>
        <div class="image-container">
            <img src="images/part3/whiteboard2.jpg" alt="Whiteboard source 2">
            <p><strong>Whiteboard Source 2</strong></p>
        </div>
    </div>
    <div class="full-width-image">
        <img src="images/part3/whiteboard_mosaic.png" alt="Whiteboard mosaic">
        <p><strong>Merged Mosaic - Whiteboard Panorama</strong></p>
    </div>
    <p>This whiteboard mosaic demonstrates planar surface alignment, with smooth blending across the seam to create a wide-angle view.</p>

    <!-- Prism.js JS -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>
</body>
</html>
